---
title: 'Field Note: Mocking a React Hook with Multiple Value Sets in Jest'
date: '2023-10-02'
tags: ['field-notes', 'women in stem', 'learning', 'learn to code']
draft: true
images: ['/static/images/posts/2022-08-30-bootcamp-to-job-hunt/direction.jpg']
summary: 'What I did after coding bootcamp to land my first full-time engineering role.'
---

**Note**: At some point, I stopped writing! Usually when this happens it's because I've been writing for a blog at work. But lately I just _haven't been writing_ ðŸ˜¯. I can't have that, but the 10,000 lb pencil is intimidated at making the longer epic-style blog posts I've done in the past.

In the spirit of "something is better than nothing"... and also in the spirit of jotting these things down so I don't forget them myself, I'm going to kick off a little "Field Notes" section here in the blog.

## Testing Hooks: The Three Step Waltz

I came across a situation last year where I was testing a component that depended upon a hook. I wanted to test how the component behaved in diferent scenarios (ie: with different return values from the hooks). This proved surprisingly difficult to do in a TypeScript-friendly way!

I discovered what I have termed a little Three Step Hook Waltz:

1. Mock the file
2. Create a mock of the function + perform some type sorcery (one line of code so we'll call it one step ðŸ˜‰)
3. MockImplementationOnce in your tests
   _Optional_: I like to include a "base case" mock return so that my tests only contain the variables I want to pay attention to. In my opinion, this makes it easier to tell what exactly is being tested where + reduces human error.

Let's break down an example of this in practice. Here, I am testing a component called `RunButton` that starts an async process. I have a hook called `useRunFlow` that tracks the process and I'd like to make sure that my button's content changes correctly based upon a few different hooks (one being this `useRunFlow`):

```TypeScript
jest.mock("hooks/useRunFlow"); // 1. Mock the file
const mockRunFlow = useRunFlow as unknown as jest.Mock<Partial<typeof useRunFlow>>; // 2. Create a mock of the function with some type sorcery
const baseUseFormOauthAdapterValues = { // I like using a base case as it keeps the tests I write cleaner
    done: false
    run: jest.fn(),
    loading: false,
};
```

"Teal," you're saying, "that's great, but you said three steps. Have you forgotten how to count? That's only two!" Ah ha, yes, the third step comes in the actual tests where you can now manipulate this hook to your heart's content.

Example:

```TypeScript
desribe("RunButton", () => {

    beforeEach(() => jest.clearAllMocks())

    it("Shows the Incomplete label if done is false", () => {
    mockRunFlow.mockImplementationOnce(() => ({
     ...mockUseFormOauthAdapter
     done: false
    }));

    render(
        <RunButton />
    );
    const button = screen.getByRole("button", { name: "Incomplete" });
    expect(button).toBeInTheDocument();
    })

    it("Shows the Run Again label if done is true", () => {
        mockRunFlow.mockImplementationOnce(() => ({
        ...mockUseFormOauthAdapter
        done: true
        }));

        render(
            <RunButton />
        );
        const button = screen.getByRole("button", { name: "Run Again" });
        expect(button).toBeInTheDocument();
    })
})
```

Et voila!
